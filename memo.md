# 메모

## 1장 블로그 서비스 최적화

- 이미지 사이즈 최적화
- 코드 분할
- 텍스트 압축
- 병목 코드 최적화

앞의 3개는 로딩 성능을 최적화이고 병목 코드 최적화는 렌더링 성능을 최적화하는 방법이다.

### 이미지 사이즈 최적화

너무 큰 사이즈의 이미지를 무분별하게 사용하면 네트워크 트래픽이 증가해 서비스 로딩이 오래 걸린다.

### 코드 분할

spa 특성상 모든 react 코드가 하나의 자바스크립트 파일로 번들링되어 로드되기 때문에, 첫 페이지 진입 시 당장 사용하지 않는 코드가 다소 포함되어 있다. 이때 코드 분할을 통해 필요없는 코드를 떼어내고, 해당 코드를 필요한 시점에 따라 로드할 수 있다.

### 텍스트 압축

웹페이지를 접속하면 다양한 리소스를 내려받는데, 그중 html, css, js 가 포함되어 있다. 이런 리소스는 다운로드 전에 서버에서 미리 압축할 수 있다. 그러면 원래 사이즈보다 더 작은 사이즈로 다운로드할 수 있어 웹페이지가 더 빠르게 로드된다.

### 병목 코드 최적화

특정 js 코드 때문에 서비스가 너무 느리게 다운로드되거나 느리게 실행되는 경우가 있다. 이런 코드를 어떻게 찾아내고 어떻게 최적화 할 수 있는지 알아보자.

### 개발자 도구의 performance 패널

웹 페이지가 로드될 때, 실행되는 모든 작업을 보여준다. 이 패널을 통해 어떤 js 코드가 느린지 확인할 수 있다.

### webpack-bundle-analyzer

이 툴은 webpack을 통해 번들링된 파일이 어떤 코드, 즉 어떤 라이브러리를 담고 있는지 보여준다. 최종적으로 완성된 번들 파일 중 불필요한 코드가 어떤 코드이고, 번들 파일에서 어느 정도의 비중을 차지하고 있는지 확인할 수 있다.

- FCP (First Contentful Paint)
  페이지가 로드 될 때 브라우저가 DOM 콘텐츠의 첫 번째 부분을 렌더링 하는데 걸리는 시간에 관한 지표이다. 위 결과에서 페이지에 진입하여 첫 콘텐츠가 뜰때까지 1.4초가 걸린것을 알 수 있고, FCP는 총점의 10% 가중치를 갖는다.
- SI (Speed Index)
  콘텐츠가 시각적으로 표시되는 속도를 나타내는 지표. 10%
- LCP (Largest Contentful Paint)
  페이지가 로드될 때 화면 내에 있는 가장 큰 이미지나 텍스트 요소가 렌더링되기까지 걸리는 시간을 나타내는 지표. 25%
- TTI (Time to Imteractive)
  사용자가 페이지와 상호 작용이 가능한 시점까지는 걸리는 시간을 측정한 지표. 10%
- TBT (Total Blocking Time)
  페이지가 클릭, 키보드 입력 등의 사용자 입렭에 응답하지 않도록 차단된 시간을 총합한 지표. 30%
- CLS (Cumulative Layout Shift)
  페이지 로드 과정에서 발생하는 예기치 못한 레이아웃 이동을 측정한 지표. 15%

### 이미지 사이즈 최적화

실제 이미지 사이즈는 1200X1200 인데, 화면에 그려지는 이미지의 사이즈는 120X120 이다. 하지만 요즘 사용되는 레티나 디스플레이는 같은 공간에 더 많은 픽셀을 그릴 수 있기 때문에, 너비 기준으로 두 배 정도 큰 이미지를 사용하는 것이 적절하다.

이미지를 줄이기 위해서는 사진 편집 툴을 통해 줄이면 되는데 api를 이용해서 받아오는 이미지는 어떻게 줄일까?

Cloudinary나 CDN을 이용하는 것

- 이미지 CDN
  CDN(Content Delivery Network)이란 물리적 거리의 한계를 극복하기 위해 소비자와 가까운 곳에 콘텐츠 서버를 두는 기술을 의미한다.
  예를들어 한국에서 미국의 있는 서버의 이미지를 다운로드하는 경우, 인터넷이 아무리 빨라도 큰 물리적인 거리가 있기 때문에 다운로드에 시간이 오래 걸린다. 이를 위해 미국에 있는 서버를 미리 한국으로 복사해 두고 사용자가 이미지를 다운로드하려고 할때 미국 서버가 아닌 한국 서버에서 다운로드하도록 하는 것.
  이미지 CDN은 이미지에 특화된 CDN 이라고 볼 수 있다. 기본적인 CDN 기능과 더불어 이미지를 사용자에게 보내기 전에 특정 형태로 가공하여 전해주는 기능까지 있다. 예를들어 이미지 사이즈를 줄이거나, 특정 포맷으로 변경하는 작업이 가능하다.
  ex) http://cdn.image.com?src=[img src]&width=240&height=240

### 병목 코드 최적화

성능 탭에서 새로고침 누르기.

performance 패널 확인

- CPU 차트, 네트워크 차트, 스크린샷
  ![스크린샷 2024-09-05 00.10.02.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7a83bb8a-dc52-4f00-8921-e59d7f2a556f/f638e3e6-9c25-4877-a443-9685fe8f4e19/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-05_00.10.02.png)
  - js 실행은 노란색, 렌더링/레이아웃 작업은 보라색, 페인팅 작업은 초록색, 기타 시스템 작업은 회색
  - 이 차트를 통해 어느 타이밍에 어떤 작업이 주로 진행되고 있는지 파악할 수 있다.
  - 위의 빨간색 선은 병목이 발생하는 지점을 의미한다. 즉 특정 작업이 메인 스레드를 오랫동안 잡아두고 있다는 뜻이다.
- Network 타임라인
  ![스크린샷 2024-09-05 00.12.56.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7a83bb8a-dc52-4f00-8921-e59d7f2a556f/9513df27-f24f-4f1a-8cb0-fea073a5661d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-05_00.12.56.png)
  - 왼쪽 회색선 : 초기 연결 시간
  - 막대의 옅은 색 영역: 요청 보낸 시점부터 응답을 기다리는 시점까지의 시간
  - 막대의 짙은 색 영역: 콘텐츠 다운로드 시간
  - 오른쪽 회색 선 : 해당 요청에 대한 메인 스레드의 작업시간
- Frames, Timings, Main
  - Frames 섹션은 변화가 있을 때마다 스샷을 찍어 보여줌
  - Timings 섹션은 User Timing API를 통해 기록된 정보를 기록함
  - Main 섹션은 브라우저의 메인 스레드에서 실행되는 작업을 플레임 차트를 통해 보여준다.
- 하단 탭

  - Summary, Bottom-up Call Tree, Event log 에서는 전체 또는 선택된 영역의 상세 내용을 확인할 수 있다.
  - Summary는 선택 영역에서 발생한 작업 시간의 총합과 각 작업이 차지하는 비중을 보여준다
  - Bottom-up 탭은 가장 최하위에 있는 작업부터 상위 작업까지 역순으로 보여준다.
  - Call Tree는 Bottom-up과 반대로 가장 상위 작업부터 하위 작업 순으로 작업 내용을 트리뷰로 보여준다.
  - Event Log 탭은 발생한 이벤트를 보여준다. Loading, Experience, Scripting, Rendering, Painting이 있다.

- 성능탭의 네트워크 자세히 보기를 이용한 분석으로 병목 코드 발견하기
  ![스크린샷 2024-09-06 23.55.16.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7a83bb8a-dc52-4f00-8921-e59d7f2a556f/46a81834-b3c4-4f8e-80d2-fc9b2271e2c1/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-06_23.55.16.png)
  - 이중 반복문을 정규표현식으로 개선 후
    ![스크린샷 2024-09-07 00.01.46.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7a83bb8a-dc52-4f00-8921-e59d7f2a556f/744ec2ea-001c-4f9b-a57b-805d1eb2edf5/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-07_00.01.46.png)
- webpack bundle analyzer 라는 npm 툴로 번들 파일 분석
  ![스크린샷 2024-09-07 00.05.26.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7a83bb8a-dc52-4f00-8921-e59d7f2a556f/969722ed-d55f-448b-b363-60bdcd2ddf5b/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-07_00.05.26.png)
  refractor 패키지의 출처를 알아보기 위해선 lock 파일을 보면 되는데 살펴보면
  ![스크린샷 2024-09-07 00.16.11.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7a83bb8a-dc52-4f00-8921-e59d7f2a556f/13a33953-1267-4d8a-ab11-7302fb9f75b3/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2024-09-07_00.16.11.png)
  상세페이지에서 마크다운으로 변경해주는 코드블록을 사용할때 사용한다. 하지만 상세에 진입했을때 사용하므로 처음부터 다운받을 필요는 없어보인다. 이 번들 파일을 분리하여 필요할때 로드하도록 변경해보기 위핸 코드 분할이 필요하다. 코드분할은 페이지별로 코드를 분리하여 하나의 번들 파일을 여러 개의 파일로 쪼개는 방법이다. 분할된 코드가 사용자가 서비스를 이용하는 중 해당 코드가 필요해지는 시점에 로드되어 실행되는데 이를 지연 로딩이라고 한다.
  블로그로 예시를 들면 글 목록 페이지와 상세 페이지 코드가 하나의 파일로 만들어지는데 이를 분리하는 것이다. 다양한 패턴이 있다.
- 코드 분할 적용하기

  ```jsx
  // prior

  import { add } from './math';
  console.log('1+4=', add(1, 4));

  // optimize
  // 동적(dynamic) import
  import('add').then((module) => {
    const { add } = module;
    console.log('1+4=', add(1, 4));
  });
  ```

  이렇게 하면 런타임에 해당 모듈을 로드한다.
  하지만 이렇게 하면 promise 형태로 모듈을 반환해서 promise 밖으로 빼야하는데 이때 lazy와 suspense를 사용한다

  ```jsx
  import React, { Suspense } from 'react';

  const SomeComponent = React.lazy(()=> import ('./SomeComponent')

  function MyComponent () {
  	return (
  		<div>
  			<Suspense fallback={<div>Loading...</div>}>
  				<SomeComponent />
  			</Suspense>
  		</div>
  	)
  }
  ```

  lazy 함수는 동적 import를 호출하여 그 결과인 Promise를 반환하는 함수를 인자로 받는다.

### 텍스트 압축

cra에서 production 환경과 development 환경은 다르다. production일때 webpack에서 경량화, 난독화 등 추가적인 최적화 작업이 일어난다. production 환경에서는 npm run build파일을 통해 서비스한다. 1/3배 정도 압축됨. 상세 페이지를 light house로 검사하면 점수가 낮을 수 있는데 그중 Enable text compression을 보자.

서버로부터 리소스를 받을 때, 텍스트 압축을 해서 받아라 라는 뜻인데 텍스트 압축이란 리소스의 크기를 줄이는 기법중 하나로 Content-Encoding:gzip이라는 표기가 articles API 응답헤더에 포함되어 있다. 이 리소스를 gzip이라는 방식으로 압축했다는 뜻이다.

![image.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/7a83bb8a-dc52-4f00-8921-e59d7f2a556f/9c6354ee-55e8-4d8c-8161-d53e8b08707d/image.png)

그에 반해 main 번들파일에는 해당 항목이 없는데 텍스트 압축이 적용되지 않았다는 뜻이다.

웹에서 사용하는 압축 방식은 크게 2가지인데 gzip과 Deflate이다. de-flate는 LZ77이라는 알고리즘과 허프먼 코딩을 사용하여 데이터를 감싸는 매우 인기있는 압축방식이다. gzip은 블록화, 휴리스틱 필터링, 헤더와 체크섬과 함께 내부적으로는 De-flate를 사용한 압축 방식으로 Deflate보다 높은 압축률을 자랑한다.

텍스트 압축을 적용하기 위해서는 serve 라이브러리에 u 옵션을 제거하면 된다. s 옵션은 spa 서비스를 위해 매칭되지 않는 주소는 모두 index.html로 보낸다는 뜻이고 u 옵션은 텍스트 압축을 하지 않겠다는 옵션이다.
